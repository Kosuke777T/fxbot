MT5 時刻ズレ修正 → CSVが最新足まで追記）
0) 症状（最初に起きていたこと）

MT5の最新M5は進んでいるのに、USDJPY_M5.csv の time.max が 2026-01-19 15:00:00 で止まり続ける

ensure_ohlcv_uptodate() は mt5_last が進んでいるのに append_rows=0 のまま

copy_rates_range() が返す max が変、copy_rates_from() フォールバックも collected 0 rows になっていた

1) 原因（確定）

MT5が返す tick.time(epoch) がローカルの now_epoch より約 +2時間未来になっていた

観測ログ：delta_sec=7198 → delta_hours_round=2

その結果、epoch→JST 変換を “UTC基準” として扱うロジックがズレて、

range取得の時刻が不正

fallback paging の “終端 dt_to” も不正

→ 必要区間に入らず 0行になる

2) 対応方針（最小差分）

“ミチビキ内部の naive datetime は JST” を前提に維持したまま、

MT5のepochがUTCからズレている分だけ補正する（+2h 等）

さらに、MT5 APIが naive datetime を「サーバ時刻」として解釈している可能性に備えて、

fallback（copy_rates_from）に渡す dt_to を server-naive に寄せる

3) 実装した修正（要点）
A. SERVER_OFFSET_SEC を導入（グローバル）

SERVER_OFFSET_SEC: int = 0 を追加

main() の [time_audit] で now_epoch と tick_epoch の差分から 1時間丸めで確定

例：SERVER_OFFSET_SEC = 7200

B. epoch→JST変換 jst_from_mt5_epoch() に補正を追加

pd.to_datetime(..., utc=True) で作った時刻から
SERVER_OFFSET_SEC を引いて補正してから JST化する

C. copy_rates_from() 用に _to_server_naive() を追加

JST naive → server naive（= “壁時計”）に寄せる

fallback では dt_to = _to_server_naive(end_ts) を使うよう変更

D. 観測ログを強化してチョークポイントを可視化

[time_audit]（ローカルとMT5のズレ）

rangeの range_insufficient ログ

fallbackの df_raw.time.max epoch / utc / jst ログ

df_new.time dtype と merged.max ログ

4) 結果（観測で確定：復旧）

SERVER_OFFSET_SEC=7200 を観測で確定

fallbackが collected 0 → fetched rows=57 に改善

USDJPY_M5.csv の末尾が更新：

csv_tail_before: 2026-01-19 15:00:00

csv_tail_after : 2026-01-19 19:45:00

append_rows=57

CSV実体でも確認：

time.max: 2026-01-19 19:45:00

rows: 112816

5) 2026-01-19 15:00:00 は何の時間だった？

これは “CSV（JST naive運用）の最終ローソク足の時刻”

当初は時刻ズレのせいで、その先（15:05〜）が取得・マージされず、CSVの最終時刻が15:00で固定されていた

今回の補正で 15:05以降が入って更新された

6) いまの状態（完了判定）

✅ UnicodeDecodeError も解消済み（subprocess出力デコード耐性）

✅ symbol正規化（CSVパス用）と MT5 symbol（実取得用）の分離も完了

✅ 時刻ズレ（server_offset +2h）を吸収して、M5自動更新が最新足まで追記できる状態に復旧

✅ ensure_ohlcv_uptodate() が append_rows > 0 を出し、推論も動く（infer_rowsが出る）

#今後起こりうる問題
今の状態でも「動く」けど、このまま開発を続けると起きやすい問題はわりとハッキリしてる。ざっくり言うと “+2時間補正が正しい前提” をコードが抱え込んでしまったのが最大の地雷。

1) サーバ時刻オフセットが変動すると壊れる（最重要）

今回 SERVER_OFFSET_SEC=7200（+2h）を、tick.time と now_epoch の差から丸めて決めてるよね。
これ、以下で変わり得る：

ブローカー/サーバの運用（DST/サマータイム、サーバ移行、メンテ）

端末PCの時計ズレやNTP不調

MT5が返す tick.time の意味（サーバ時刻扱い）の揺れ

変動した瞬間に

CSVの時間が飛ぶ/戻る

取得がまた0行になったり、重複・欠損が出たり
が起きる。

対策の方向性：
SERVER_OFFSET_SEC は「観測して自動推定」でもいいけど、(a) ログに毎回出して監視、(b) しきい値超えで警告/停止、(c) できれば設定で固定 or MT5側の公式情報で確定、が安全。

2) JST naive の“内部標準”が増殖して、別系統の時刻と混ざる

今の実装は「ミチビキ内部の naive datetime は JST」というローカルルールで回ってる。
これ自体はアリなんだけど、

他のサービスが UTC-aware を返す

pandas が timezone を持ったSeriesを返す

JSONLに tz付きISOが混ざる

みたいな経路が増えると、同じ“19:45”でも意味が違う事故が起きる。

症状例：可視化は合ってるのに、推論の時系列がズレる／ラベルが逆転／窓関数の境界がずれる。

対策：
「保存（CSV/JSONL）」「内部計算」「MT5入出力」の3境界だけでも、必ずどの時刻表現かを固定するのが吉（例：保存はUTC ISO8601、内部はUTC-aware、表示だけJST、みたいな）。

3) copy_rates_range と copy_rates_from の“解釈差”が残る

今回 _to_server_naive() を fallback に入れたけど、range系は3方式トライで、まだ挙動がサーバやビルドで揺れやすい。

症状例：
ある日は range がまともに埋まるが、別の日は range_insufficient→fallback の頻度が増える、など。

対策：
「rangeは信用せず、常にfrom_posで最新N本＋CSV追記」みたいな 取得戦略の単純化が一番安定。

4) append_rows の計算が“CSV tail基準”なので、時間が戻ると壊れる

もし何かの拍子に変換が逆転して、CSVに 過去の時刻が混ざると

tailが更新されない

dedupで消える

append_rowsが0のまま
になって「また止まった」に見える。

対策：
CSVに書く直前に 単調増加チェック（timeが増えてない行が混ざったら警告・スキップ）を入れると強い。

じゃあ「今すぐ」やるべき最低限の安全策は？

コードを大きく変えずに、事故を早期発見できるやつ：

SERVER_OFFSET_SEC を毎回 INFO で出す（すでに出てるならOK）

前回の offset と違ったら WARNING（±3600以上変化で停止でもいい）

CSV書き込み前に merged["time"].is_monotonic_increasing をチェックして、崩れてたら WARNING + その回は保存しない

これだけで「静かに壊れて、あとで地獄」確率が激減する。

結論：
今の状態で続けると問題が出る可能性はあるけど、危険の中心は server offset の揺れと naive/JSTの混在。
先に「ズレが起きた瞬間に検知して止まる」ガードを入れておけば、開発速度を落とさずに安全に進められる。