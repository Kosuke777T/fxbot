最高。ここまで具体なら、あとは“実装順序”と“落とし穴回避”が鍵です。まずは仕様に少しだけ追記してから、ゼロ→運用までの作業リスト（DoD=完了条件つき）を一気に並べます。

# 追記しておくと安全になるルール（最小限の抜け漏れ）

* **プロセス設計**：GUI(メイン)／市場データ購読（非同期）／売買実行（逐次）／学習（別プロセス）の**分離**。学習・最適化は必ず別プロセスにしてGUIを固めない。
* **フェイルセーフ**：

  1. “本口座”ボタンは**二段階確認**＋`max_lot_cap`制限必須。
  2. **日次DDストップ**・**連敗ストップ**・**スリッページ急増**でサーキットブレーカー。
  3. **max_positions=1**をブローカー側の約定応答待ちロックで厳守（非同期競合対策）。
* **ロット算出の基準**：`lot = floor((equity/100000)*1)/100` ではなく**明示**：「有効証拠金 10,000 円で 0.01 lot、20,000 円で 0.02 lot…」＝ `lot = max(min_lot, round_down(equity/1_000_000, 2))`（USDJPY/標準口座想定。ブローカーの最小ロット・刻みに合わせて正規化）。
* **時刻軸**：全ログ・集計は**JST**基準、ブローカーサーバ時刻との差は統一ラッパで吸収。
* **データ品質**：MT5履歴の**ギャップ検知**・**重複バー除去**・**TZ補正**を前処理で強制。欠損 >0.5% なら学習中止。
* **モデル管理**：`models/`下に**署名（SHA256）**と**メタ情報（特徴量定義のハッシュ）**を保存。特徴量ズレ検知で**強制ブロック**。
* **ログ基準**：全トレードに**Decision Trace**（入力→各モデル予測→メタ判定→最終注文）をJSONで保存。再現性を確保。
* **Sakura VPS(2GB)**：LSTMは小型化（隠れ次元≤64、層≤2）＋バッチ学習は週末のみ。平時はLightGBM/XGBoostの推論中心。

---

# 全体アーキテクチャ（ざっくり）

* **UI層（PyQt6 + PyQtGraph + matplotlib）**
  Qtスレッド＝GUI専用。ZMQ/Queueでバックエンドの状態を購読。
* **バックエンド（Python 3.13）**

  * 市場データ購読：MT5 API → 内部Pub/Subバスへ
  * シグナル推論：前処理→特徴量→各モデル→メタモデル
  * 執行：注文ラッパ（リトライ、価格改善、約定イベント）
  * ロガー：構造化JSON + ローテーション
* **学習/バッチ**（週末）：データ抽出→特徴量→学習→WFO→最適化→モデル署名→配布
* **設定**：`config.yaml`（デモ／本番切替、リスク、戦略、学習パラメータ）＋`.env`（口座認証）

---

# 作業リスト（フェーズ別・完了条件つき）

## フェーズ0：環境/骨格（MVPの土台）

1. **Python 3.13 + MT5 + PyQt6 セットアップ**

   * 依存：`MetaTrader5`, `PyQt6`, `pyqtgraph`, `matplotlib`, `lightgbm`, `xgboost`, `numpy`, `pandas`, `scikit-learn`, `joblib`, `shap`, `pydantic`, `pyyaml`, `loguru`
   * **DoD**：`python -c "import MetaTrader5; print('ok')"`が通る。MT5接続テストOK（デモ口座）。

2. **リポジトリ雛形 & フォルダ構成**

   ```
   fxai/
     app/                 # GUI
     core/                # 取引/推論/執行
     data/                # キャッシュ・生成特徴量
     models/              # pkl/onnx + meta.json
     logs/                # 構造化ログ
     batch/               # 学習・WFO・最適化
     tests/               # pytest
     config.yaml
     .env.example
     README.md
   ```

   * **DoD**：`pytest -q`が最低限パス、`pre-commit`でblack/isort/ruff通過。

3. **設定ファイル雛形（デモ/本番切替）**

   ```yaml
   account:
     mode: demo           # demo | live
     server: "OANDA-XYZ"
   risk:
     max_positions: 1
     daily_loss_stop: 0.02
     dd_stop: 0.10
     slip_stop_pips: 2.0
     lot:
       min: 0.01
       step: 0.01
       formula: "scale_10000yen_per_0_01lot"
       max_cap: 0.50
   strategy:
     symbol: "USDJPY"
     timeframes: ["M15","H1"]   # Phase1
     entry_threshold: 0.60
     tp_sl:
       mode: "fixed"            # fixed | atr | ai
       tp_pips: 15
       sl_pips: 10
   features:
     ema: [10,20,50]
     rsi: [14]
     atr: [14]
     adx: [14]
     bbands: [20,2.0]
     lookback: 1000
   training:
     val_ratio: 0.2
     cv_folds: 5
     enable_lstm: false
   logging:
     level: "INFO"
     jst: true
   ```

   * **DoD**：`pydantic`等でバリデーションが通る。

## フェーズ1：GUIの骨格 + 口座/ポジション可視化

4. **Dashboardタブ（口座＋ポジション一覧）**

   * MT5口座情報を5秒更新、ポジションをテーブル表示（Buy=青/Sell=赤）
   * **DoD**：残高/Equity/含み損益/ポジ数/ロット合計が正確、色分けOK、NPEなし。
5. **Controlタブ（Start/Stop/学習/バックテストボタン、スライダー）**

   * 取引ON/OFFトグル、ロット／閾値スライダー、SL/TP入力
   * **DoD**：UI操作→バックエンド設定に即反映。誤操作ガード表示。

## フェーズ2：データ取得→特徴量→推論（M15+H1、固定TP/SL）

6. **履歴取得・前処理**

   * MT5からM15/H1のOHLCVをDL、ギャップ・重複処理、JST整列
   * **DoD**：欠損率<0.5%、ユニットテストで時系列一貫性OK。
7. **特徴量生成（共通）**

   * EMA/RSI/ATR/ADX/BB、変化率、出来高、ヒゲ比率など
   * **DoD**：`features.parquet`生成、列メタ（定義ハッシュ）保存。
8. **ラベリング**

   * 例：`y_dir`（10バー後の上昇/下降/横ばい）＋`y_pips`（回帰）
   * **DoD**：クラス分布・ターゲットリーク検査OK。
9. **個別モデル（LGB/XGB）学習 & 推論API**

   * まず**分類(LGB, XGB)**と**回帰(LGB)**。LSTMは無効で進む。
   * **DoD**：`predict_proba/predict_pips`がjsonableで返る、推論<5ms/サンプル（VPS）。
10. **メタモデル（ロジスティック or LGB）**

* 各モデルの出力→最終Buy/Sell/Skip
* **DoD**：検証AUC/Loglossが単体モデルを上回ること（最低わずかでも）。

## フェーズ3：執行レイヤ & サーキットブレーカー

11. **発注ラッパ（成行/SL/TP/約定イベント）**

* 価格ズレ再試行、ネットワーク/タイムアウト耐性
* **DoD**：サンドボックスでミニ発注→約定→クローズまで自動完了。

12. **max_positions=1の強制**

* **約定待ちロック**（in-flight注文がある間は新規禁止）
* **DoD**：ストレステストで同時信号でも2件目はブロックされる。

13. **ロット計算（有効証拠金スケール）**

* `lot = max(min_lot, round_to_step(equity/1_000_000, step))`、`<= max_cap`
* **DoD**：10,000円→0.01 lot、20,000円→0.02 lot…の確認テスト。

14. **サーキットブレーカー**

* 日次DD/総DD/スリッページ急増/連敗 N 回
* **DoD**：閾値到達で自動停止、UIに赤バナー表示、手動解除のみ再開。

## フェーズ4：AIタブ/Chartタブの“見える化”

15. **AIタブ**

* 勝率/PF/DD/連勝連敗/総取引、モデル名、最新学習日時、直近確率バー、FIランキング（LGB/XGB）、SHAP上位3
* **DoD**：最新の推論イベントからリアルタイム更新、SHAPはキャッシュ利用で即時描画。

16. **Chartタブ**

* エクイティ曲線、DD推移、時間帯×日付ヒートマップ、AI確率の時系列
* **DoD**：1日10,000点超でも滑らか（pyqtgraph使用）、CPU占有<40%。

## フェーズ5：出口の進化（ATR→AI最適化）

17. **固定TP/SL → ATR連動**

* 強トレンド時TP拡張、レンジ時短縮
* **DoD**：週次ABテストで基準よりPF↑かDD↓のいずれかを達成。

18. **AI出口（回帰pred_pips＋勢いスコア）**

* 目標TP/SLとトレーリング開始点をメタ最適化
* **DoD**：WFOで基準比 シャープ↑、または最大DD↓を確認。

## フェーズ6：運用評価・ドリフト・週末ジョブ

19. **KPI/SLOウォッチャー**

* 移動窓のPF/勝率/期待値/スリッページ等
* **DoD**：SLO割れで自動「縮小運転」へ（ロット1/2、または停止）。

20. **ドリフト検知**

* PSI/KL/KS＋性能（Brier/Logloss）
* **DoD**：警告→緊急再学習ジョブ起動（別プロセス）。

21. **週末バッチ（学習・WFO・最適化）**

* 土曜朝JST：学習→WFO→ベイズ最適→モデル署名→展開
* **DoD**：自動レポート（HTML/PDF）生成→Logタブ通知。

## フェーズ7：M5の追加→スタッキング完成

22. **M5特徴の追加（タイミング補完）**

* 短期EMA傾き/ヒゲ比/直近ATR 等
* **DoD**：エントリーの平均不利約定距離（slippage方向）改善、または平均保持時間短縮。

23. **M15+M5+H1のスタッキング**

* 3系の出力をメタで統合
* **DoD**：WFOでPhase2比の総合改善（PF or DD or Sharpe）。

---

# 主要モジュールと責務（実装時の地図）

* `core/mt5_client.py`：接続、相場購読、発注、約定イベント
* `core/position_guard.py`：max_positions、約定待ちロック、重複防止
* `core/risk_manager.py`：日次DD・総DD・連敗・スリッページ監視
* `core/feature_pipeline.py`：履歴DL→前処理→特徴量保存/ロード
* `core/models/`：`lgb_clf.py` `xgb_clf.py` `lgb_reg.py` `lstm.py` `meta_model.py`
* `core/inference.py`：各モデル推論→メタ判定→シグナル出力
* `core/execution.py`：注文生成、SL/TP設定、リトライ
* `core/logger.py`：構造化ログ、Decision Trace
* `app/gui.py`：PyQt6各タブ、スレッド安全な購読
* `batch/train.py`：学習、モデル保存、メタJSON出力（特徴量ハッシュ含む）
* `batch/walkforward.py`：期間スキーム、集計、DoD判定
* `batch/optimize.py`：ベイズ最適化（閾値/ATR係数/トレール係数）
* `tests/`：ユニット＋統合テスト（疑似MT5スタブ）

---

# Logタブのイベント規約（例）

```json
{
  "ts_jst":"2025-10-30T13:05:12",
  "type":"trade_open",
  "symbol":"USDJPY",
  "signal":{"p_buy":0.67,"p_sell":0.31,"meta":"BUY"},
  "features_hash":"a1b2c3...",
  "models":{"lgb_clf":0.64,"xgb_clf":0.62,"lgb_reg_pred_pips":8.3},
  "order":{"req_lot":0.03,"lot":0.03,"sl_pips":10,"tp_pips":15},
  "guard":{"inflight":false,"max_positions":1},
  "slippage":0.2
}
```

---

# ムード表示（AIステータス）

* ルール：直近N分の**ATR変化率**・**成行拒否率**・**トレンド強度(ADX)**で3状態を判定
  例：「市場は静穏」「ボラ急上昇注意」「トレンド反転警戒中」
* DoD：ムード状態が閾値でヒステリシス制御（ピコピコ切替防止）

---

# テスト計画（要点）

* **機能**：max_positions競合、ロット計算、DDストップ、発注リトライ、データギャップ処理
* **性能**：推論QPS、UI描画FPS、I/O待ち
* **回帰**：特徴量ハッシュが変わったら旧モデルを拒否
* **バックテスト**：WFOで`PF, Sharpe, MaxDD, Win%`の四天王を最低出力

---

# 省メモリ＆高速化メモ（2GB想定）

* pandasは`float32`/`int32`に縮小、特徴量は**学習用と推論用で列最小化**
* LightGBMは`num_leaves`と`feature_fraction`で軽量化
* SHAPは**説明用サンプルをサブセット**（上位最近2000件など）
* LSTMは**週末のみ**トレーニング、平時は凍結推論 or 無効

---

# 初回スプリント（1週間目の着地イメージ）

1. フェーズ0〜1を完了（GUI骨格＋口座/ポジ表示＋制御系）
2. フェーズ2の前処理〜単体LGB分類の推論まで通し
3. **デモ口座**で1日ペーパートレード運用→ログ検証

---

# 次に広げるなら

* 本番切替の**二重確認**
* 「失敗パターンのマイニング」から**自動フィルタ候補**生成
* 週末ジョブの**HTMLレポート**（モデル比較・KPIダッシュボード）

このリストで実装すれば、まずは**M15+H1×固定TP/SL**の安定稼働→徐々に**ATR/AI出口**→**M5統合のスタッキング**という、壊れにくい進化コースになります。次は「フェーズ0〜1のテンプレ（ひな形コード／`config.yaml`／GUIワイヤー）」を私から用意して、そのままVS Codeで走るところまで一気にいきましょう。
